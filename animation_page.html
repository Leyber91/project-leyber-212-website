<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Black Hole Animation</title>
  <link rel="stylesheet" href="assets\css\styles.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Orbitron&display=swap" /><!-- Link to your main CSS stylesheet -->

  <style>
    /* Add any additional CSS rules specific to the animation page here */
    #animation-container {
      position: relative;
      width: 100%;
      height: 100%;
    }
    #start-animation {
      position: absolute;
      top: 10px;
      left: 10px;
    }
    #back-to-main {
      position: absolute;
      top: 10px;
      right: 10px;
    }
  </style>
</head>
<body>
    <div id="animation-container">
        <!-- Add a button to start the animation -->
        <button id="start-animation">Start Animation</button>
    
        <!-- Add a button to go back to the main page -->
        <button id="back-to-main">Back to Main Page</button>
      </div>
    
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="assets\js\LensFlare.js"></script>
  <script>
    let blackHole;
    function createRadialGradientTexture(size) {
        const canvas = document.createElement("canvas");
        canvas.width = size;
        canvas.height = size;
        const context = canvas.getContext("2d");

        const gradient = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
        gradient.addColorStop(0, "rgba(255, 255, 255, 1)");
        gradient.addColorStop(0.5, "rgba(255, 255, 255, 0.5)");
        gradient.addColorStop(1, "rgba(255, 255, 255, 0)");

        context.fillStyle = gradient;
        context.fillRect(0, 0, size, size);

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        return texture;
        }

    // Set up the 3D environment using a WebGL library such as Three.js
    function setupScene() {
    // Set up the renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create a scene
    const scene = new THREE.Scene();

    // Create a camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    // Create the black hole mesh
    const blackHole = createBlackHole();

    // Add the black hole to the scene
    scene.add(blackHole);

    // Add a resize event listener
    window.addEventListener('resize', () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
    });

    return { scene, camera, renderer }
};


    // Set up an animation loop
    function animate() {
    requestAnimationFrame(animate);
    animateBlackHole();
    animateAccretionDisk();
    renderer.render(scene, camera);
    }

    function setup() {
    // Set up the renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create a scene
    const scene = new THREE.Scene();

    // Create a camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    // Add a resize event listener
    window.addEventListener('resize', () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
    });

    return { scene, camera, renderer }
    }


    // Initialize the 3D environment
    const { scene, camera, renderer } = setup



    // Create the event horizon geometry
    function createEventHorizon() {
      const geometry = new THREE.TorusGeometry(1.5, 0.5, 16, 100);
      return geometry;
    }

    // Create the black hole material with shaders
    function createBlackHoleMaterial() {
      const vertexShader = `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;

      const fragmentShader = `
        varying vec2 vUv;
        void main() {
          float intensity = 1.0 - distance(vUv, vec2(0.5, 0.5)) * 2.0;
          gl_FragColor = vec4(vec3(intensity), 1.0);
        }
      `;

      const material = new THREE.ShaderMaterial({
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide,
        transparent: true,
        depthWrite: false,
      });

      return material;
    }

    // Create the black hole mesh
    function createBlackHole() {
      const geometry = createEventHorizon();
      const material = createBlackHoleMaterial();
      const mesh = new THREE.Mesh(geometry, material);
      return mesh;
    }

    // Add the black hole to the scene
    scene.add(blackHole);

    // Generate random positions within the accretion disk
    function getRandomPositionInDisk(radius, innerRadius) {
      const angle = Math.random() * Math.PI * 2;
      const distance = innerRadius + Math.random() * (radius - innerRadius);
      const x = Math.cos(angle) * distance;
      const y = Math.sin(angle) * distance;
      return new THREE.Vector3(x, y, (Math.random() - 0.5) * 0.2);
    }

    // Create the accretion disk geometry
    function createAccretionDiskGeometry(particleCount, radius, innerRadius) {
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        const position = getRandomPositionInDisk(radius, innerRadius);
        positions[i * 3] = position.x;
        positions[i * 3 + 1] = position.y;
        positions[i * 3 + 2] = position.z;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      return geometry;
    }

    // Create the accretion disk material with shaders
    function createAccretionDiskMaterial() {
      const vertexShader = `
        varying vec3 vColor;
        void main() {
          vColor = vec3(1.0, 0.5, 0.2) * clamp(length(position) / 5.0, 0.0, 1.0);
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = 0.05 * (300.0 / length(mvPosition.xyz));
          gl_Position = projectionMatrix * mvPosition;
        }
      `;

      const fragmentShader = `
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        void main() {
          gl_FragColor = vec4(vColor, 1.0) * texture2D(pointTexture, gl_PointCoord);
        }
      `;

      const material = new THREE.ShaderMaterial({
        uniforms: {
            pointTexture: { value: createRadialGradientTexture(64) },
        },
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });

      return material;
    }

    // Create the accretion disk points
    function createAccretionDisk(particleCount, radius, innerRadius) {
      const geometry = createAccretionDiskGeometry(particleCount, radius, innerRadius);
      const material = createAccretionDiskMaterial();
      const disk = new THREE.Points(geometry, material);
      return disk;
    }

    // Add the accretion disk to the scene
    const accretionDisk = createAccretionDisk(10000, 5, 2);
    scene.add(accretionDisk);

    // Add ambient light to the scene
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);

    // Create a point light
    function createPointLight(color, distance, intensity) {
      const light = new THREE.PointLight(color, intensity, distance);
      return light;
    }

    // Create and position point lights
    function createAndPositionPointLights() {
      const pointLight1 = createPointLight(0xffaa00, 30, 1);
      pointLight1.position.set(5, 3, 5);
      scene.add(pointLight1);

      const pointLight2 = createPointLight(0xffaa00, 30, 1);
      pointLight2.position.set(-5, 3, 5);
      scene.add(pointLight2);

      const pointLight3 = createPointLight(0xffaa00, 30, 1);
      pointLight3.position.set(0, 3, -5);
      scene.add(pointLight3);
    }

    // Add point lights to the scene
    createAndPositionPointLights();

    // Function to animate the black hole
    function animateBlackHole() {
      blackHole.rotation.z += 0.005;
    }

    // Function to animate the accretion disk
    function animateAccretionDisk() {
      accretionDisk.rotation.z -= 0.002;
    }

    function init() {
    animate();
  }

  </script>
<script>
    // Update the event listener for the "Start Animation" button to call init()
    document.getElementById("start-animation").addEventListener("click", () => {
      init();
      document.getElementById("start-animation").disabled = true;
    });
  
    document.getElementById("back-to-main").addEventListener("click", () => {
      // Navigate back to the main page
      window.location.href = "index.html";
    });
  </script>
  
    
</body>
</html>


